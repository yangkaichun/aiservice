<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>醫療數位孿生儀表板</title>
    <!-- 引入 Google Fonts 'Inter' -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        /* --- 0. 基本設置與佈局 --- */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #000c18; /* 深藍色背景 */
            color: #e0e0e0;
            margin: 0;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden; /* 隱藏滾動條 */
        }

        .dashboard-container {
            width: 95%;
            height: 95%;
            max-width: 1600px;
            max-height: 900px;
            display: grid;
            /* * 重新設計: "T" 型佈局
             * 1. 標題
             * 2. 病床總覽 (全寬)
             * 3. 人體孿生 (左) | 詳情 (右)
            */
            grid-template-areas:
                "header header"
                "beds beds"
                "human details";
            grid-template-rows: auto auto 1fr; /* 標題和病床自動高度, 剩下給底部 */
            grid-template-columns: 2fr 1fr; /* 底部 2:1 比例 */
            gap: 20px;
            padding: 20px;
            box-sizing: border-box; /* 確保 padding 不影響總寬高 */
        }

        header {
            grid-area: header;
            text-align: center;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
        }

        #header-logo {
            width: 50px;
            height: 50px;
            object-fit: contain;
            filter: drop-shadow(0 0 8px #00b3ff);
        }

       .widget {
            /* * 重新設計: 更簡潔的面板
             * 移除了 backdrop-filter, box-shadow, transform
            */
            background: #001a2c; /* 更紮實的深藍色 */
            border: 1px solid #005f80; /* 亮藍色邊框 */
            border-radius: 8px;
            padding: 20px;
            
            display: flex;
            flex-direction: column;
            
            /* * 修正:
             * 移除了 overflow: auto，因為新佈局不再需要
             * min-height: 0 是 Grid / Flex 佈局的最佳實踐，防止子元素溢出
            */
            min-height: 0;
            overflow: hidden; /* 隱藏內部的溢出 (如果有的話) */
        }

        /* 移除了 .widget:hover 特效 */

       .widget h3 {
            margin-top: 0;
            color: #00b3ff; /* 標題亮藍色 */
            text-shadow: 0 0 10px #00b3ff;
            border-bottom: 1px solid #005f80;
            padding-bottom: 10px;
        }

        /* --- 1. 病床總覽 (頂部) --- */
       .bedside-twin {
            grid-area: beds;
            /* 高度由內容決定 (auto) */
        }

        /* * 重新設計: 
         * 使用 Flexbox 取代單一 SVG，彈性更大
        */
       .bedside-container {
            display: flex;
            justify-content: space-around;
            align-items: center;
            gap: 20px;
            padding: 10px 0;
        }

       .bed-button {
            /* * 這是新的可點擊元素
             * 替代了原來的 <use class="room">
            */
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            padding: 10px;
            border: 2px solid #005f80;
            border-radius: 8px;
            background: rgba(0, 118, 163, 0.3);
            cursor: pointer;
            transition: background 0.3s, border-color 0.3s;
        }
        
       .bed-button svg {
            width: 80px;
            height: 60px;
            fill: #00b3ff; /* 圖示顏色 */
            stroke: #00b3ff;
            stroke-width: 2;
        }

       .bed-button span {
            color: #fff;
            font-weight: 500;
        }

       .bed-button:hover {
            background: rgba(0, 179, 255, 0.5);
        }

       .bed-button.selected {
            background: rgba(0, 179, 255, 0.9);
            border-color: #fff;
            transform: scale(1.05);
        }

       .bed-button.alert {
            background: rgba(255, 66, 66, 0.8); /* 警報紅色 */
            border-color: #ff0000;
            animation: pulse-alert 1s infinite alternate; /* 警報閃爍動畫 */
        }
        
       .bed-button.alert svg {
            fill: #ff0000;
            stroke: #ff0000;
        }


        /* --- 2. 人體孿生 (左下) --- */
       .human-twin {
            grid-area: human;
            /* 允許內容在需要時滾動 (例如小螢幕) */
            overflow-y: auto; 
        }
        
       /* 移除了 .avatar-container */

        /* * 新增: 人體掃描容器
         * 這將取代舊的頭像，並包含熱點
        */
       .body-scan-container {
            position: relative; /* 讓熱點 (hotspots) 可以絕對定位 */
            width: 100%;
            max-width: 300px; /* 限制最大寬度以保持長寬比 */
            margin: 0 auto 20px auto; /* 置中並增加底部間距 */
        }

        #body-scan-image {
            width: 100%;
            border-radius: 8px;
            opacity: 0.8; /* 使其看起來更像 "掃描" */
        }

        /* * 新增: 熱點 (Hotspots) 樣式
        */
       .hotspot {
            position: absolute;
            width: 15px;
            height: 15px;
            background-color: #00b3ff;
            border: 2px solid #fff;
            border-radius: 50%;
            cursor: pointer;
            animation: pulse-hotspot 1.5s infinite ease-in-out;
            box-shadow: 0 0 15px #00b3ff;
            transition: transform 0.2s;
        }

       .hotspot:hover {
            transform: scale(1.3); /* 滑鼠懸停時放大 */
        }

        /* 根據圖片估算的熱點位置 (使用百分比以保持響應性) */
       .hotspot.brain { top: 8%; left: 47%; }
       .hotspot.heart { top: 25%; left: 48%; }
       .hotspot.lungs { top: 32%; left: 38%; }
       .hotspot.arm-bp { top: 30%; left: 25%; } /* BP (手臂) */

        /* * 新增: 熱點跳動動畫
        */
        @keyframes pulse-hotspot {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* * 新增: 數據塊 (data-block)
         * 用於 JS 識別和添加 highlight
        */
       .vital, .graph-wrapper {
            /* 添加 .data-block 類以便 JS 選取 */
            transition: transform 0.3s, box-shadow 0.3s, border-color 0.3s;
        }

        /* * 新增: 熱點懸停時的目標高亮樣式
        */
       .data-block.highlight {
            border-color: #00b3ff;
            box-shadow: 0 0 20px rgba(0, 179, 255, 0.7);
            transform: scale(1.02); /* 輕微放大 */
        }


       .vitals-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr); /* 2x2 網格 */
            grid-template-rows: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

       .vital {
            background: #000;
            border: 1px solid #005f80;
            padding: 10px;
            border-radius: 5px;
        }

       .vital .label {
            font-size: 0.9rem;
            color: #a0cfff;
            margin-bottom: 5px;
        }

       .vital .value {
            font-size: 1.8rem;
            font-weight: 500;
            color: #fff;
            text-shadow: 0 0 8px #fff; 
        }

       .vital .unit {
            font-size: 0.9rem;
            color: #a0cfff;
            margin-left: 5px;
        }

        /* 動態圖表容器 */
       .graphs-container {
            flex-grow: 1; /* 填滿剩餘的垂直空間 */
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-height: 200px; /* 確保圖表有最小高度 */
        }

       .graph-wrapper {
            flex-grow: 1; /* 每個圖表均分空間 */
            display: flex;
            flex-direction: column;
            background: #000;
            border: 1px solid #005f80; /* 匹配 vitals 邊框 */
            border-radius: 4px;
            padding: 5px;
        }

       .graph-label {
            color: #00b3ff;
            margin: 0 0 5px 5px;
            font-size: 0.9rem;
            font-weight: 400;
        }

        #ecg-canvas, #eeg-canvas {
            width: 100%;
            flex-grow: 1; /* 畫布填滿 wrapper */
            border-radius: 4px;
        }


        /* --- 3. 詳情面板 (右下) --- */
       .details-panel {
            grid-area: details;
            /* 高度由 grid-template-rows: 1fr 決定 */
        }

       .details-content p {
            background: #000;
            padding: 10px;
            border-radius: 4px;
            border-left: 3px solid #00b3ff;
            margin: 15px 0;
            display: flex;
            justify-content: space-between;
        }
       .details-content p strong {
            color: #a0cfff;
            margin-right: 10px;
        }
       .details-content p span {
            color: #fff;
        }

        /* 狀態指示燈 */
       .status-dot {
            height: 15px;
            width: 15px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 10px;
            box-shadow: 0 0 10px;
        }
       .status-dot.online {
            background-color: #00ff00;
            box-shadow: 0 0 10px #00ff00;
        }
       .status-dot.offline {
            background-color: #ff4242;
            box-shadow: 0 0 10px #ff4242;
        }


        /* --- 4. 動畫 --- */
        @keyframes pulse-alert {
            from {
                opacity: 1;
                box-shadow: 0 0 10px #ff0000;
            }
            to {
                opacity: 0.7;
                box-shadow: 0 0 20px #ff0000;
            }
        }
        
        /* * 重新設計:
         * 將 SVG 病床圖示定義在 <defs> 中，
         * 這樣可以被 .bed-button 重複使用
        */
        .svg-defs {
            position: absolute;
            width: 0;
            height: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <!-- SVG 定義區 -->
    <svg class="svg-defs">
        <symbol id="bed-icon" viewBox="0 0 100 80">
            <title>Bed Icon</title>
            <!-- 床架 (Headboard) -->
            <path d="M10,10 H30 V50 H10 Z" />
            <!-- 床墊 (Mattress) -->
            <path d="M30,30 H90 V50 H30 Z" />
            <!-- 腿 (Legs) -->
            <path d="M35,50 V60 H45 V50 Z" />
            <path d="M75,50 V60 H85 V50 Z" />
        </symbol>
    </svg>

    <div class="dashboard-container">
        <header>
            <img id="header-logo" src="fetlogo.png" alt="FET Logo"
                 onerror="this.style.display='none'">
            <h1>醫療數位孿生儀表板 (Demo)</h1>
        </header>

        <!-- 
          * 佈局重構: 
          * 移除 .main-content 和 .sidebar
          * .bedside-twin, .human-twin, .details-panel 現在是 .dashboard-container 的直接子元素
        -->
        
        <!-- 模組 B: 病床孿生 (新位置: 頂部) -->
        <div class="widget bedside-twin">
            <h3>病床孿生 (ICU床號)</h3>
            <!-- 
              * 重新設計: 
              * 使用 Flexbox 容器和按鈕
            -->
            <div class="bedside-container">
                <div class="bed-button" id="room-101">
                    <svg><use href="#bed-icon" /></svg>
                    <span>ICU 101</span>
                </div>
                <div class="bed-button" id="room-102">
                    <svg><use href="#bed-icon" /></svg>
                    <span>ICU 102</span>
                </div>
                <div class="bed-button" id="room-103">
                    <svg><use href="#bed-icon" /></svg>
                    <span>ICU 103</span>
                </div>
                <div class="bed-button" id="room-104">
                    <svg><use href="#bed-icon" /></svg>
                    <span>ICU 104</span>
                </div>
            </div>
        </div>

        <!-- 模組 A: 人體孿生 (新位置: 左下) -->
        <div class="widget human-twin">
            <h3 id="human-twin-title">人體孿生 (Patient-001)</h3>
            
            <!-- 
              * 重新設計: 
              * 移除 .avatar-container，替換為 .body-scan-container
            -->
            <div class="body-scan-container">
                <!-- 
                  * 這是您要求的圖片
                  * SRC 路徑已預留為 "image_afa66b.jpg"
                  * 如果找不到圖片，將顯示一個錯誤佔位符
                -->
                <img id="body-scan-image" src="digitwin.jpg" alt="Body Scan"
                     onerror="this.src='https://placehold.co/300x500/001a2c/FF0000?text=找不到圖片'; this.style.opacity=1;">
                
                <!-- 新增: 互動熱點 -->
                <div class="hotspot brain" data-target="data-block-eeg" title="腦波圖 (EEG)"></div>
                <div class="hotspot heart" data-target="data-block-ecg" title="心電圖 (ECG)"></div>
                <div class="hotspot lungs" data-target="data-block-spo2" title="血氧 (SpO2)"></div>
                <div class="hotspot arm-bp" data-target="data-block-bp" title="血壓 (BP)"></div>
            </div>

            <!-- 
              * 結構更新: 
              * 為 Vitals 和 Graphs 添加 .data-block 和唯一的 ID，
              * 以便熱點可以鎖定它們
            -->
            <div class="vitals-grid">
                <div class="vital data-block" id="data-block-hr">
                    <div class="label">心率 (HR)</div>
                    <span class="value" id="vital-hr">72</span>
                    <span class="unit">bpm</span>
                </div>
                <div class="vital data-block" id="data-block-bp">
                    <div class="label">血壓 (BP)</div>
                    <span class="value" id="vital-bp">120/80</span>
                    <span class="unit">mmHg</span>
                </div>
                <div class="vital data-block" id="data-block-spo2">
                    <div class="label">血氧 (SpO2)</div>
                    <span class="value" id="vital-spo2">98</span>
                    <span class="unit">%</span>
                </div>
                <div class="vital data-block" id="data-block-rr">
                    <div class="label">呼吸 (RR)</div>
                    <span class="value" id="vital-rr">16</span>
                    <span class="unit">/min</span>
                </div>
            </div>

            <div class="graphs-container">
                <div class="graph-wrapper data-block" id="data-block-ecg">
                    <h4 class="graph-label">心電圖 (ECG)</h4>
                    <canvas id="ecg-canvas"></canvas>
                </div>
                <div class="graph-wrapper data-block" id="data-block-eeg">
                    <h4 class="graph-label">腦波圖 (EEG) - 5 通道</h4>
                    <canvas id="eeg-canvas"></canvas>
                </div>
            </div>
        </div>

        <!-- 模組 C: 詳情面板 (新位置: 右下) -->
        <div class="widget details-panel">
            <h3 id="details-name">ICU 病房 101</h3>
            <div class="details-content">
                <p>
                    <strong>狀態</strong>
                    <span>
                        <span class="status-dot online" id="details-status-dot"></span>
                        <span id="details-status-text">Online</span>
                    </span>
                </p>
                <p><strong>病患 ID</strong> <span id="details-patient">Patient-001</span></p>
                <p><strong>主要設備</strong> <span id="details-equipment">Ventilator V-100</span></p>
            </div>
        </div>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {

            // --- 1. 緩存 DOM 元素 ---
            const hrElement = document.getElementById('vital-hr');
            const bpElement = document.getElementById('vital-bp');
            const spo2Element = document.getElementById('vital-spo2');
            const rrElement = document.getElementById('vital-rr');
            
            /* * 修正 (FIX): 
             * 選擇器從 '.facility-map .room' 更改為 '.bed-button'
            */
            const roomButtons = document.querySelectorAll('.bed-button');
            
            const detailsName = document.getElementById('details-name');
            const detailsStatusDot = document.getElementById('details-status-dot');
            const detailsStatusText = document.getElementById('details-status-text');
            const detailsPatient = document.getElementById('details-patient');
            const detailsEquipment = document.getElementById('details-equipment');

            const humanTwinTitle = document.getElementById('human-twin-title');
            const patientAvatar = document.getElementById('patient-avatar'); // 注意: 這個元素現在已被移除

            const ecgCanvas = document.getElementById('ecg-canvas');
            const ecgCtx = ecgCanvas.getContext('2d');
            const eegCanvas = document.getElementById('eeg-canvas');
            const eegCtx = eegCanvas.getContext('2d');


            // --- 2. 數據模擬引擎 ---
            
            const patientDatabase = {
                "room-101": { 
                    patientId: "Patient-001", 
                    avatarUrl: "p1.jpg",
                    equipment: "Ventilator V-100", 
                    status: "online",
                    baseVitals: { hr: 72, bpSys: 120, bpDia: 80, spo2: 98, rr: 16 }
                },
                "room-102": { 
                    patientId: "Patient-002", 
                    avatarUrl: "p2.jpg",
                    equipment: "Dialysis D-50", 
                    status: "online",
                    baseVitals: { hr: 85, bpSys: 130, bpDia: 85, spo2: 97, rr: 18 }
                },
                "room-103": { 
                    patientId: "Patient-003", 
                    avatarUrl: "p3.jpg",
                    equipment: "ECMO E-20", 
                    status: "online",
                    baseVitals: { hr: 68, bpSys: 110, bpDia: 75, spo2: 99, rr: 14 }
                },
                 "room-104": { 
                    patientId: "Patient-004",
                    avatarUrl: "p4.jpg",
                    equipment: "Infusion Pump I-300",
                    status: "online",
                    baseVitals: { hr: 75, bpSys: 115, bpDia: 78, spo2: 98, rr: 16 }
                },
            };

            let currentBaseVitals = null;
            let currentSelectedRoom = 'room-101'; 

            // 模擬生命體徵
            setInterval(function simulateVitals() {
                if (!currentBaseVitals) {
                    hrElement.innerText = '--';
                    spo2Element.innerText = '--';
                    rrElement.innerText = '--';
                    bpElement.innerText = '--/--';
                    return;
                }
                hrElement.innerText = Math.floor(Math.random() * 5) + (currentBaseVitals.hr - 2);
                spo2Element.innerText = Math.floor(Math.random() * 2) + (currentBaseVitals.spo2 - 1);
                rrElement.innerText = Math.floor(Math.random() * 2) + (currentBaseVitals.rr - 1);
                let sys = Math.floor(Math.random() * 5) + (currentBaseVitals.bpSys - 2);
                let dia = Math.floor(Math.random() * 3) + (currentBaseVitals.bpDia - 1);
                bpElement.innerText = `${sys}/${dia}`;
            }, 1500);

            // 模擬設施狀態
            setInterval(function simulateFacility() {
                if (Math.random() > 0.7) {
                    const occupiedRooms = ["room-101", "room-102", "room-103", "room-104"];
                    let randomRoom = occupiedRooms[Math.floor(Math.random() * occupiedRooms.length)];
                    let roomEl = document.getElementById(randomRoom);
                    
                    if (roomEl) {
                        if (roomEl.classList.contains('alert')) {
                            roomEl.classList.remove('alert');
                            patientDatabase[randomRoom].status = "online";
                        } else {
                            roomEl.classList.add('alert');
                            patientDatabase[randomRoom].status = "alert";
                        }
                        
                        if (roomEl.classList.contains('selected')) {
                            updateDetails(randomRoom);
                        }
                    }
                }
            }, 5000);


            // --- 3. 設施地圖互動 ---

            function updateHumanTwin(roomId) {
                const data = patientDatabase[roomId];
                if (!data) return;
                currentBaseVitals = data.baseVitals;
                
                /* * 移除對 patientAvatar 的更新，因為它已被 body scan 取代
                 * patientAvatar.src = data.avatarUrl; 
                 * patientAvatar.style.borderColor = '#00b3ff';
                */
                
                humanTwinTitle.innerText = `人體孿生 (${data.patientId})`;
                if (!data.baseVitals) {
                    simulateVitals();
                }
            }

            function updateDetails(roomId) {
                const data = patientDatabase[roomId];
                if (!data) return;
                /* * 修正 (FIX):
                 * 移除了 .replace(...) 後面多餘的 ')'
                */
                detailsName.innerText = roomId.toUpperCase().replace('ROOM', 'ICU ');
                detailsPatient.innerText = data.patientId;
                detailsEquipment.innerText = data.equipment;
                
                if (data.status === 'online') {
                    detailsStatusText.innerText = "Online";
                    detailsStatusDot.className = "status-dot online";
                } else if (data.status === 'alert') {
                    detailsStatusText.innerText = "Alert!";
                    detailsStatusDot.className = "status-dot offline";
                } else {
                    detailsStatusText.innerText = "Offline";
                    detailsStatusDot.className = "status-dot offline";
                }
            }

            /* * 修正 (FIX): 
             * 事件監聽器綁定到新的 '.bed-button' 元素
            */
            roomButtons.forEach(button => {
                button.addEventListener('click', function() {
                    roomButtons.forEach(p => p.classList.remove('selected'));
                    this.classList.add('selected');
                    
                    currentSelectedRoom = this.id;
                    updateDetails(currentSelectedRoom);
                    updateHumanTwin(currentSelectedRoom);
                });
            });

            // --- 4. 畫布繪圖引擎 ---
            
            /* * 修正 (FIX): 
             * 補回遺失的 'const ecgWaveform = [' 宣告
            */
            const ecgWaveform = [
                100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 
                100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
                100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
                100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 
                102, 105, 103, 100, 98, 95, 180, 90, 95, 100, 
                105, 110, 108, 105, 100, 100, 100, 100, 100, 100,
                100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
                100, 100, 100, 100, 100, 100, 100, 100, 100, 100
            ];
            let ecgDataIndex = 0;
            let ecgX = 0;
            const ecgStep = 2; 

            const eegLines = 5; 
            let eegX = 0;
            const eegStep = 2;
            let lastEegY = new Array(eegLines).fill(0);
            
            function resizeCanvases() {
                setTimeout(() => {
                    if (ecgCanvas.offsetWidth > 0) {
                        ecgCanvas.width = ecgCanvas.offsetWidth;
                        ecgCanvas.height = ecgCanvas.offsetHeight;
                        ecgCtx.strokeStyle = '#00ff00';
                        ecgCtx.lineWidth = 2;
                        ecgCtx.shadowBlur = 5;
                        ecgCtx.shadowColor = '#00ff00';
                    }
                    
                    if (eegCanvas.offsetWidth > 0) {
                        eegCanvas.width = eegCanvas.offsetWidth;
                        eegCanvas.height = eegCanvas.offsetHeight;
                        eegCtx.strokeStyle = '#FFFF00';
                        eegCtx.lineWidth = 1; 

                        for (let i = 0; i < eegLines; i++) {
                            lastEegY[i] = (eegCanvas.height / (eegLines + 1)) * (i + 1);
                        }
                    }
                }, 50); 
            }
            
            function drawEcgWave() {
                if (ecgCanvas.height === 0) return; 

                let canvasHeight = ecgCanvas.height;
                let baseHeight = canvasHeight / 1.8;
                let scale = canvasHeight / 200; 

                ecgCtx.clearRect(ecgX, 0, ecgStep + 10, canvasHeight);
                ecgCtx.beginPath();
                
                let y1_val = ecgWaveform[ecgDataIndex];
                let y2_index = (ecgDataIndex + 1) % ecgWaveform.length;
                let y2_val = ecgWaveform[y2_index];

                let canvasY1 = baseHeight - (y1_val - 100) * scale; 
                let canvasY2 = baseHeight - (y2_val - 100) * scale;

                ecgCtx.moveTo(ecgX, canvasY1);
                ecgCtx.lineTo(ecgX + ecgStep, canvasY2);
                ecgCtx.stroke();

                ecgX += ecgStep;
                ecgDataIndex = y2_index;
                
                if (ecgX > ecgCanvas.width) {
                    ecgX = 0; 
                }
            }

            function drawEegWave() {
                if (eegCanvas.height === 0) return; 

                let canvasHeight = eegCanvas.height;
                let baseSpacing = canvasHeight / (eegLines + 1);
                let amplitude = baseSpacing * 0.4; 

                eegCtx.clearRect(eegX, 0, eegStep + 10, canvasHeight);

                for (let i = 0; i < eegLines; i++) {
                    let currentBaseY = baseSpacing * (i + 1);
                    let newY = currentBaseY + (Math.random() - 0.5) * amplitude;

                    eegCtx.beginPath();
                    eegCtx.moveTo(eegX, lastEegY[i]);
                    eegCtx.lineTo(eegX + eegStep, newY);
                    eegCtx.stroke();
                    
                    lastEegY[i] = newY;
                }
                
                eegX += eegStep;

                if (eegX > eegCanvas.width) {
                    eegX = 0;
                    for (let i = 0; i < eegLines; i++) {
                         lastEegY[i] = (eegCanvas.height / (eegLines + 1)) * (i + 1);
                    }
                }
            }

            function animateGraphs() {
                drawEcgWave();
                /* * 修正 (FIX): 
                 * 這裡應該是 drawEegWave() 而不是 drawEcgWave()
                */
                drawEegWave();
                
                /* * 修正 (FIX): 
                 * 必須使用 requestAnimationFrame 
                 * 而不是直接遞歸調用，否則會導致堆疊溢位 (stack overflow)
                */
                requestAnimationFrame(animateGraphs);
            }

            // --- 5. 啟動 ---
            
            window.addEventListener('resize', resizeCanvases);
            
            resizeCanvases(); 
            animateGraphs();  

            // 設置初始選中狀態
            document.getElementById(currentSelectedRoom).classList.add('selected');
            updateDetails(currentSelectedRoom);
            updateHumanTwin(currentSelectedRoom);

            // --- 6. 新增: 熱點互動 ---
            const hotspots = document.querySelectorAll('.hotspot');
            const dataBlocks = document.querySelectorAll('.data-block'); // 緩存所有數據塊

            hotspots.forEach(hotspot => {
                const targetId = hotspot.dataset.target;
                const targetElement = document.getElementById(targetId);

                if (targetElement) {
                    // 滑鼠懸停: 高亮
                    hotspot.addEventListener('mouseover', () => {
                        // 移除所有現有的高亮
                        dataBlocks.forEach(block => block.classList.remove('highlight'));
                        
                        // 添加高亮到目標元素
                        targetElement.classList.add('highlight');
                        
                        // (可選) 滾動到該元素
                        // targetElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    });

                    // 滑鼠移出: 移除高亮
                    hotspot.addEventListener('mouseout', () => {
                        targetElement.classList.remove('highlight');
                    });
                }
            });
        });
    </script>
</body>
</html>
